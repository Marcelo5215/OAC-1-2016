#=============================================================================#
#          Trabalho 1 - Organizacao e arquitetura de Computadores             #
#              Marcelo de Araujo Lopes Junior - 150016794                     #
#               Pedro Henrique Pires Egler - 150044615                        #
#                     Luiza Amanajas - 160056659                              #
#=============================================================================#

.data

image_name:     .asciiz "lenaeye.raw"
address: 	      .word   0x10040000	    # endereco do bitmap display na memoria
buffer:		      .word   0		            # configuracao default do MARS
size:		      .word   4096		    # numero de pixels da imagem
bm_width:             .word   64                   # altura do bitmap
bm_height:            .word   64                   # largura do bitmap
str_size:       .word   21              # tamanho da string padrao
menu_str:       .asciiz "Escolha a opcao desejada:\n1.  get_point\n2.  draw_point\n3.  draw_empty_rectangle\n4.  convert_negative\n5.  load_image\n6.  Exit\n"
load_image_str: .asciiz "Digite o nome da imagem:\n"
print_str:      .word   4
read_int:       .word   5
read_str:       .word   8
x_str:          .asciiz "Insira o valor x do ponto: "
y_str:          .asciiz "Insira o valor y do ponto: "
RGB_R_str:      .asciiz "Valor de R: "
RGB_G_str:      .asciiz "Valor de G: "
RGB_B_str:      .asciiz "Valor de B: "

.text
  jal menu

  li $v0 10		# end program
  syscall

# APRESENTA O MENU PARA O USUARIO :
#
#
#
#
#
menu:

  lw    $v0, print_str        # preparando syscall para imprimir a string do menu
  la    $a0, menu_str         # string do menu
  syscall
  lw    $v0, read_int         # prepara o syscall para pegar a opcao do usuario
  syscall                     # $v0 contem o valor lido
  beq    $v0, 1, get_point              # if $v0 == 1 then get_point
  beq    $v0, 2, draw_point             # if $v0 == 2 then draw_point
  beq    $v0, 3, draw_empty_rectangle   # if $v0 == 3 then draw_empty_rectangle
  beq    $v0, 4, convert_negative       # if $v0 == 4 then convert_negative
  beq    $v0, 5, load_image             # if $v0 == 5 then load_image

  jr $ra



# DOCUMENTACAO DA ROTINA
#
#
#
#
#
get_point:

  
   

  j    menu        # jump to menu






#-------------------------------------------------------------------------
# Funcao draw_point: função que, com parametros x e y de um ponto e  
# informações de cor inseridos pelo usuário, desenha um ponto no bitmap
# display com a cor correspondente
# 
# Parametros:
#   $a1: x
#   $a2: y
#   $a3: cor
#   $t1: valor R de RGB
#   $t2: valor G de RGB
#   $t3: valor B de RGB
#   $t4: largura do bitmap
#   $t5: altura do bitmap
#   $t6: endereço da cabeça do bitmap
#
# A função foi implementada ...

draw_point:

  lw $t4, bm_width
  lw $t5, bm_height
  lw $t6, address

  lw $v0, print_str                  # preparando syscall para exibir a string de x
  la $a0, x_str                      # string de x
  syscall
  lw $v0, read_int                   # prepara o syscall para pegar o valor de x
  syscall                            # $v0 contem o valor lido
  move $a1, $v0                      # valor de x movido de $v0 para $a1 
 
  lw $v0, print_str                  # preparando syscall para exibir a string de y                          
  la $a0, y_str                      # string de y
  syscall
  lw $v0, read_int                   # prepara o syscall para pegar o valor de y
  syscall                            # $v0 contem o valor lido
  move $a2, $v0                      # valor de y movido de $v0 para $a2
  sub  $a2, $t4, $a2                 # subtrai y de 64 pra começar de baixo pra cima
  subi $a2, $a2, 1
  
  lw $v0, print_str                  # preparando syscall para exibir a string de R de RGB
  la $a0, RGB_R_str                  # string de R
  syscall
  lw $v0, read_int                   # prepara o syscall para pegar o valor de R
  syscall                            # $v0 contem o valor lido
  move $t1, $v0                      # valor de R movido de $v0 para $t1 
  
  sll $t1, $t1, 16                   # joga o valor de $t1 16 bits para a esquerda
  add $a3, $zero, $t1                # soma $t1 com zero e o resultado vai para $a3
  
  lw $v0, print_str                  # preparando syscall para exibir a string de G de RGB                          
  la $a0, RGB_G_str                  # string de G
  syscall
  lw $v0, read_int                   # prepara o syscall para pegar o valor de G
  syscall                            # $v0 contem o valor lido
  move $t2, $v0                      # valor de G movido de $v0 para $t2
  
  sll $t2, $t2, 8                    # joga o valor de $t2 8 bits para a esquerda
  add $a3, $a3, $t2                  # soma $a3 com $t2 e o resultado vai para $a3
  
  lw $v0, print_str                  # preparando syscall para exibir a string de B de RGB                        
  la $a0, RGB_B_str                  # string de B
  syscall
  lw $v0, read_int                   # prepara o syscall para pegar o valor de B
  syscall                            # $v0 contem o valor lido
  move $t3, $v0                      # valor de B movido de $v0 para $t3
  
  add $a3, $a3, $t3                  # soma $a3 com $t3 e o resultado vai para $a3
  
  multu $a2, $t5	             # multiplica y pela altura		
  mflo $a2			     # recupera resultado
  addu $a1, $a1, $a2		     # soma x
  sll $a1, $a1, 2		     # multiplica por 4 para obter o endereço
  
  add $a1, $a1, $t6                  # encontra endereço do bitmap
  
  sw $a3, ($a1)                      # coloca informação de cor no endereço
  

  j    menu        # jump to menu
